<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
<meta name="referrer" content="no-referrer" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lfeng.tech","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="5 AOP5.1 什么是AOPAOP（Aspect-Oriented Programming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC系列-(5) AOP">
<meta property="og:url" content="https://lfeng.tech/2020/04/01/Spring_5_AOP/index.html">
<meta property="og:site_name" content="Vincent&#39;s Notes">
<meta property="og:description" content="5 AOP5.1 什么是AOPAOP（Aspect-Oriented Programming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gco2xb0bj9j20nn0cet8m.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdlvhys8j20rw04sac1.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdmieawqj20l2032aaw.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdmulonyj20l0030dhc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbpcjfy280j20gs05hjsi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbpckrle5gj209d07n3zi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbtwioiufvj20r00b2q93.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbumpbeny2j20f40d4gn5.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbun9ltq7pj20o006l0uo.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbun9zgx02j20o00etn2j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbv2c4r97gj21vc0uotdf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzgtx2vgj20zw10wqe9.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzmgsqh5j218m0oqaid.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzuwcgm7j21e00ckq7x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0avcjmfj21by0aa799.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0ep3jluj21b20d210u.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0izo4mrj211q0oqn55.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0nefn1dj215k0pe7d6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0xmzbi7j20hc072dgv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3t0xzq5j218o0xe14b.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3u8s3yyj20ys044wfo.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3zupf2uj212g03475x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx40maqalj21bi0fejw9.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx4945g10j216s0vetis.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx4i1p4gej211y0xkh99.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx5y40f0wj213o0qqkav.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx6zhw7bbj217y17u1kx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx7z0215aj214k14i1kx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx8yj3uzkj21400ia4c8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbx9fi7k0mj20z40tcdyn.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbyhmky2zkj21h40vgaml.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbyifaonl8j212t07edix.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbyiu5grwlj20zq0bw7gs.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbyiwqa07zj20wi04y75j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gbyixtkqwbj20ny0d0tc6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gc0l5guzy6j21980muwjf.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mhglpmxj21980x2tl8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mnavf7gj20wm0h0415.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mshjq0bj218u0pq7ap.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1g9v9luujswj21n10l9jux.jpg">
<meta property="article:published_time" content="2020-03-31T21:43:49.000Z">
<meta property="article:modified_time" content="2020-05-28T04:06:09.286Z">
<meta property="article:author" content="Vincent">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/a18449c6gy1gco2xb0bj9j20nn0cet8m.jpg">

<link rel="canonical" href="https://lfeng.tech/2020/04/01/Spring_5_AOP/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring MVC系列-(5) AOP | Vincent's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vincent's Notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lfeng.tech/2020/04/01/Spring_5_AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincent's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring MVC系列-(5) AOP
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-31 21:43:49" itemprop="dateCreated datePublished" datetime="2020-03-31T21:43:49Z">2020-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-28 04:06:09" itemprop="dateModified" datetime="2020-05-28T04:06:09Z">2020-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/04/01/Spring_5_AOP/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/04/01/Spring_5_AOP/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gco2xb0bj9j20nn0cet8m.jpg" alt="Spring.png"></p>
<h2 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5 AOP"></a>5 AOP</h2><h3 id="5-1-什么是AOP"><a href="#5-1-什么是AOP" class="headerlink" title="5.1 什么是AOP"></a>5.1 什么是AOP</h3><p>AOP（Aspect-Oriented Programming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</p>
<p>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<span id="more"></span>

<p><strong>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即切面。所谓“切面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</strong></p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用拦截方法的方式，对该方法进行装饰，以取代原有对象行为的执行；二是采用静态织入的方</p>
<h3 id="5-2-AOP术语"><a href="#5-2-AOP术语" class="headerlink" title="5.2 AOP术语"></a>5.2 AOP术语</h3><p><strong>1. 连接点（Join point）</strong></p>
<p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是类的某个方法调用前、调用后、方法抛出异常后等。</p>
<p><strong>2. 通知（Advice）</strong></p>
<p>在特定的连接点，AOP框架执行的动作。</p>
<p>Spring AOP 提供了5种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法被调用之前调用通知功能。</li>
<li>后置通知（After）：在目标方法完成之后调用通知，无论该方法是否发生异常。</li>
<li>后置返回通知（After-returning）：在目标方法成功执行之后调用通知。</li>
<li>后置异常通知（After-throwing）：在目标方法抛出异常后调用通知。</li>
<li>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li>
</ul>
<p><strong>3. 切点(Poincut)</strong></p>
<p>具体定位的连接点：上面也说了，每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点。</p>
<blockquote>
<p><strong>切点与连接点</strong>：切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。每个类都拥有多个连接点，例如 ArithmethicCalculator类的所有方法实际上都是连接点。</p>
</blockquote>
<p><strong>4. 切面(Aspect)</strong></p>
<p><strong>切面由切点和通知组成</strong>，它既包括了横切逻辑的定义、也包括了连接点的定义。</p>
<p><strong>5. 织入(Weaving)</strong></p>
<p><strong>织入描述的是把切面应用到目标对象来创建新的代理对象的过程。</strong> Spring AOP 的切面是在运行时被织入，原理是使用了动态代理技术。Spring支持两种方式生成代理对象：JDK动态代理和CGLib，默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。</p>
<p><strong>6. 引入（Introduction）</strong></p>
<p>添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口。</p>
<h3 id="5-3-AOP使用"><a href="#5-3-AOP使用" class="headerlink" title="5.3 AOP使用"></a>5.3 AOP使用</h3><p>首先新建业务逻辑类，该类实现了基本的除法操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator &#123;</span><br><span class="line">	//业务逻辑方法</span><br><span class="line">	public int div(int i, int j)  &#123;</span><br><span class="line">		System.out.println(&quot;--------&quot;);</span><br><span class="line">		return i/j;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在需要实现：在div()方法运行之前, 记录一下日志, 运行后也记录一下,运行出异常,也打印一下。</p>
<p>因此可以使用AOP来完成日志的功能，新建日志切面类：</p>
<p>在定义切面类的时候，需要注意如下几点：</p>
<ul>
<li>在类上加上<code>@Aspect</code>声明为切面类。</li>
<li>可以使用PointCut将相同的切点进行统一定义，其他地方直接引用即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class LogAspects &#123;</span><br><span class="line">	@Pointcut(&quot;execution(public int com.enjoy.cap10.aop.Calculator.*(..))&quot;)</span><br><span class="line">	public void pointCut()&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	//@before代表在目标方法执行前切入, 并指定在哪个方法前切入</span><br><span class="line">	@Before(&quot;pointCut()&quot;)</span><br><span class="line">	public void logStart(JoinPoint joinPoint)&#123;</span><br><span class="line">		System.out.println(joinPoint.getSignature().getName()+&quot;除法运行....参数列表是:&#123;&quot;+Arrays.asList(joinPoint.getArgs())+&quot;&#125;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@After(&quot;pointCut()&quot;)</span><br><span class="line">	public void logEnd(JoinPoint joinPoint)&#123;</span><br><span class="line">		System.out.println(joinPoint.getSignature().getName()+&quot;除法结束......&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	@AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)</span><br><span class="line">	public void logReturn(Object result)&#123;</span><br><span class="line">		System.out.println(&quot;除法正常返回......运行结果是:&#123;&quot;+result+&quot;&#125;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)</span><br><span class="line">	public void logException(Exception exception)&#123;</span><br><span class="line">		System.out.println(&quot;运行异常......异常信息是:&#123;&quot;+exception+&quot;&#125;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*@Around(&quot;pointCut()&quot;)</span><br><span class="line">	public Object Around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable&#123;</span><br><span class="line">		System.out.println(&quot;@Arount:执行目标方法之前...&quot;);</span><br><span class="line">		Object obj = proceedingJoinPoint.proceed();//相当于开始调div地</span><br><span class="line">		System.out.println(&quot;@Arount:执行目标方法之后...&quot;);</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了以上操作, 我们还需要将切面类和被切面的类, 都加入到容器中，注意需要加上<code>@EnableAspectJAutoProxy</code>开启AOP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 日志切面类的方法需要动态感知到div()方法运行, </span><br><span class="line"> *  通知方法:</span><br><span class="line"> *     前置通知:logStart(); 在我们执行div()除法之前运行(@Before)</span><br><span class="line"> *     后置通知:logEnd();在我们目标方法div运行结束之后 ,不管有没有异常(@After)</span><br><span class="line"> *     返回通知:logReturn();在我们的目标方法div正常返回值后运行(@AfterReturning)</span><br><span class="line"> *     异常通知:logException();在我们的目标方法div出现异常后运行(@AfterThrowing)</span><br><span class="line"> *     环绕通知:动态代理, 需要手动执行joinPoint.procced()(其实就是执行我们的目标方法div,), 执行之前div()相当于前置通知, 执行之后就相当于我们后置通知(@Around)</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class Cap10MainConfig &#123;</span><br><span class="line">	@Bean</span><br><span class="line">	public Calculator calculator()&#123;</span><br><span class="line">		return new Calculator();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public LogAspects logAspects()&#123;</span><br><span class="line">		return new LogAspects();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用JoinPoint可以拿到相关的内容, 比如方法名, 参数</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdlvhys8j20rw04sac1.jpg" alt="Pictu222re1.png"></p>
<p>那么方法正常返回, 怎么拿方法的返回值呢?</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdmieawqj20l2032aaw.jpg" alt="Pictu4444re1.png"></p>
<p>那么如果是异常呢?定义</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbpdmulonyj20l0030dhc.jpg" alt="Pictur55551.png"></p>
<p>下面是测试程序，注意需要使用从IOC容器中取出Bean，否则直接new对象进行操作，AOP、无法生效。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbpcjfy280j20gs05hjsi.jpg" alt="Pict111111ure1.png"></p>
<p>从下面的运行结果可以看到，AOP生效，日志功能正常：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbpckrle5gj209d07n3zi.jpg" alt="22.png"></p>
<blockquote>
<p>小结: AOP看起来很麻烦, 只要3步就可以了:<br>1, 将业务逻辑组件和切面类都加入到容器中, 告诉spring哪个是切面类(@Aspect)<br>2, 在切面类上的每个通知方法上标注通知注解, 告诉Spring何时运行(写好切入点表达式,参照官方文档)<br>3, 开启基于注解的AOP模式  @EableXXXX</p>
</blockquote>
<h3 id="5-4-Java动态代理"><a href="#5-4-Java动态代理" class="headerlink" title="5.4 Java动态代理"></a>5.4 Java动态代理</h3><p>Spring AOP的实现是基于动态代理，在介绍具体实现细节之前，本节先介绍动态代理的原理。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在两者之间起到中介的作用（可类比房屋中介，房东委托中介销售房屋、签订合同等）。 所谓动态代理，就是实现阶段不用关心代理谁，而是在运行阶段才指定代理哪个一个对象（不确定性）。如果是自己写代理类的方式就是静态代理（确定性）。</p>
<p>很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>(动态)代理模式主要涉及三个要素： </p>
<ul>
<li>抽象类接口 </li>
<li>被代理类（具体实现抽象接口的类） </li>
<li>动态代理类：实际调用被代理类的方法和属性的类</li>
</ul>
<p><strong>实现方式:</strong> 实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了反射机制。还有其他的实现方式，比如利用字节码操作机制，类似 ASM、CGLIB（基于 ASM）、Javassist 等。 举例，常可采用的JDK提供的动态代理接口InvocationHandler来实现动态代理类。其中invoke方法是该接口定义必须实现的，它完成对真实方法的调用。通过InvocationHandler接口，所有方法都由该Handler来进行处理，即所有被代理的方法都由InvocationHandler接管实际的处理任务。此外，我们常可以在invoke方法实现中增加自定义的逻辑实现，实现对被代理类的业务逻辑无侵入。</p>
<blockquote>
<p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。 </p>
</blockquote>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>代理模式的形式如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbtwioiufvj20r00b2q93.jpg" alt="Screen Shot 2020-02-12 at 8.28.31 PM.png"></p>
<p>代理模式最大的特点就是代理类和实际业务类实现同一个接口（或继承同一父类），代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作。Java动态代理其实内部也是通过Java反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后作一些相应的处理。</p>
<p>下面举例说明：</p>
<p><strong>1. 静态代理</strong></p>
<p>若代理类在程序运行前就已经存在，那么这种代理方式被成为静态代理 ，这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下， 静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Sell &#123;</span><br><span class="line">    void sell();</span><br><span class="line">    void ad();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vendor的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Vendor implements Sell&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        System.out.println(&quot;In sell method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        System.out.println(&quot;ad method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BusinessAgent的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 静态代理，通过聚合来实现，让代理类有一个委托类的引用即可。</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BusinessAgent implements Sell&#123;</span><br><span class="line">    private Sell vendor;</span><br><span class="line">    public BusinessAgent(Sell vendor) &#123;</span><br><span class="line">        this.vendor = vendor;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void sell() &#123;</span><br><span class="line">        // 一些业务逻辑</span><br><span class="line">        System.out.println(&quot;before sell&quot;);</span><br><span class="line">        vendor.sell();</span><br><span class="line">        System.out.println(&quot;after sell&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void ad() &#123;</span><br><span class="line">        // 一些业务逻辑</span><br><span class="line">        System.out.println(&quot;before ad&quot;);</span><br><span class="line">        vendor.ad();</span><br><span class="line">        System.out.println(&quot;after ad&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看到， 通过静态代理，一方面无需修改Vendor的代码就可以加入一些业务处理逻辑；另一方面，实现了客户端与委托类的解耦。但这种静态代理的局限在于，必须在运行前编写好代理类，如果委托类的方法较多，在添加业务逻辑时的工作量较大，需要对每个方法单独添加。</p>
<p><strong>2. 动态代理</strong></p>
<p>代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p>
<p>同样还是上面的例子，需要在委托类的每个方法前后加入一些处理逻辑，在动态代理的实现中，首先需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 调用处理程序</span><br><span class="line"> * 代理类对象作为proxy参数传入，参数method标识了我们具体调用的是代理类的哪个方法，args为这个方法的参数</span><br><span class="line"> */</span><br><span class="line">public interface InvocationHandler &#123; </span><br><span class="line">    Object invoke(Object proxy, Method method, Object[] args); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>中介类必须实现InvocationHandler接口，作为调用处理器”拦截“对代理类方法的调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">    // obj为委托对象</span><br><span class="line">    private Object object;</span><br><span class="line">    public DynamicProxy(Object object) &#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时需要动态生成代理类，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /* Static proxy */</span><br><span class="line">        Vendor vendor = new Vendor();</span><br><span class="line">        BusinessAgent businessAgent = new BusinessAgent(vendor);</span><br><span class="line">        businessAgent.sell();</span><br><span class="line">        businessAgent.ad();</span><br><span class="line">        /* Dynamic proxy */</span><br><span class="line">        DynamicProxy inter = new DynamicProxy(new Vendor());</span><br><span class="line">        //加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);</span><br><span class="line">        // 获取代理实例sell</span><br><span class="line">        /**</span><br><span class="line">         * public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </span><br><span class="line">         *                                      throws IllegalArgumentException </span><br><span class="line">         * loader：定义了代理类的ClassLoder; </span><br><span class="line">         * interfaces：代理类实现的接口列表;</span><br><span class="line">         * h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例.</span><br><span class="line">         */</span><br><span class="line">        Sell sell = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[] &#123;Sell.class&#125;, inter));</span><br><span class="line">        // 通过代理类对象调用代理方法，实际上会转到invoke方法调用</span><br><span class="line">        sell.sell();</span><br><span class="line">        sell.ad();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong>： 动态代理的原理就是，首先通过newProxyInstance方法获取代理类实例，而后我们便可以通过这个代理类实例调用代理类的方法，对代理类的方法的调用实际上都会调用中介类(调用处理器)的invoke方法，在invoke方法中我们调用委托类的相应方法，并且可以添加自己的处理逻辑。</p>
</blockquote>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。</p>
<p>来看示例，假设我们有一个没有实现任何接口的类HelloConcrete：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloConcrete &#123;</span><br><span class="line">    public String sayHello(String str) &#123;</span><br><span class="line">        return &quot;HelloConcrete: &quot; + str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没有实现接口该类无法使用JDK代理，通过CGLIB代理实现如下：</p>
<ul>
<li>实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>
<li>在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// CGLIB动态代理</span><br><span class="line">// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</span><br><span class="line">class MyMethodInterceptor implements MethodInterceptor&#123;</span><br><span class="line">  ...</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        logger.info(&quot;You said: &quot; + Arrays.toString(args));</span><br><span class="line">        return proxy.invokeSuper(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。</span><br><span class="line">Enhancer enhancer = new Enhancer();</span><br><span class="line">enhancer.setSuperclass(HelloConcrete.class);</span><br><span class="line">enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line">HelloConcrete hello = (HelloConcrete)enhancer.create();</span><br><span class="line">System.out.println(hello.sayHello(&quot;I love you!&quot;));</span><br><span class="line">// 输出结果如下</span><br><span class="line">// 日志信息: You said: [I love you!]</span><br><span class="line">// HelloConcrete: I love you!</span><br></pre></td></tr></table></figure>

<p>通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，<strong>对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等</strong>；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。</p>
<blockquote>
<p>CGLIB是通过继承(<code>如上面例子中的enhancer.setSuperclass(HelloConcrete.class)</code>)实现代理，由于final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出异常。</p>
</blockquote>
<h3 id="5-5-AOP原理深入分析"><a href="#5-5-AOP原理深入分析" class="headerlink" title="5.5 AOP原理深入分析"></a>5.5 AOP原理深入分析</h3><p>AOP的原理简单来讲，利用动态代理，在IOC容器初始化时，创建Bean的代理类；在代理方法被调用时，代理类会拦截方法的调用，并在之前或者之后插入切面方法，以此实现AOP的目标。</p>
<p>接下来会从以下几方面深入分析AOP的原理：</p>
<ul>
<li>AnnotationAwareAspectJAutoProxyCreator注册</li>
<li>AnnotationAwareAspectJAutoProxyCreator分析</li>
<li>AOP流程分析</li>
</ul>
<h4 id="AnnotationAwareAspectJAutoProxyCreator注册"><a href="#AnnotationAwareAspectJAutoProxyCreator注册" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator注册"></a>AnnotationAwareAspectJAutoProxyCreator注册</h4><p>在之前使用AOP时，为了启用AOP，需要在配置类中，声明<code>@EnableAspectJAutoProxy</code>的注解，这个注解的功能就是注册<code>AnnotationAwareAspectJAutoProxyCreator</code>。下面具体分析这个组件是如何注册的。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbumpbeny2j20f40d4gn5.jpg" alt="Screen Shot 2020-02-13 at 11.47.39 AM.png">@w=250</p>
<p>进入<code>@EnableAspectJAutoProxy</code>的源码中，可以看到该类引入了<code>AspectJAutoProxyRegistrar</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Import(AspectJAutoProxyRegistrar.class)</span><br><span class="line">public @interface EnableAspectJAutoProxy &#123;</span><br><span class="line">    //proxyTargetClass属性，默认false，采用JDK动态代理织入增强(实现接口的方式)；如果设为true，则采用CGLIB动态代理织入增强</span><br><span class="line"> 	boolean proxyTargetClass() default false;</span><br><span class="line">    //通过aop框架暴露该代理对象，aopContext能够访问</span><br><span class="line"> 	boolean exposeProxy() default false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AspectJAutoProxyRegistrar</code>中, 可以看到实现了ImportBeanDefinitionRegistrar接口，这个接口之前也有介绍，能给容器中自定义注册组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span><br><span class="line">	 * of the @&#123;@link EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span><br><span class="line">	 * &#123;@code @Configuration&#125; class.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(</span><br><span class="line">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">		if (enableAspectJAutoProxy != null) &#123;</span><br><span class="line">			if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注<code>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</code>，这一步将会注册<code>AnnotationAwareAspectJAutoProxyCreator</code>。下面进入源码，</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbun9ltq7pj20o006l0uo.jpg" alt="Pict111ure1.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbun9zgx02j20o00etn2j.jpg" alt="Pictur222e1.png"></p>
<p>程序的逻辑很清晰，</p>
<ul>
<li>如果(registry.containsBeanDefinition(ATUO_PROXY_CREATOR_BEAN_NAME))也就是容器中bean已经有了 internalAutoProxyCreator, 执行内部内容，返回null。</li>
<li>如果没有，创建AnnotationAwareAspectJAutoProxyCreator信息; 把此bean注册在registry中.<br>做完后, 相当于给容器中注册internalAutoProxyCreator组件, 该组件类型为AnnotationAwareAspectJAutoProxyCreator.class。（ 注意这里ATUO_PROXY_CREATOR_BEAN_NAME值为internalAutoProxyCreator）</li>
</ul>
<blockquote>
<p><strong>综上分析，@EnableAspectJAutoProxy的功能就是，利用其中的AspectJAutoProxyRegistrar给我们容器中注册一个AnnotationAwareAspectJAutoProxyCreator组件，这是后续创建增强Bean的基础。</strong></p>
</blockquote>
<h4 id="AnnotationAwareAspectJAutoProxyCreator分析"><a href="#AnnotationAwareAspectJAutoProxyCreator分析" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator分析"></a>AnnotationAwareAspectJAutoProxyCreator分析</h4><p>AnnotationAwareAspectJAutoProxyCreator的类层次结构如下图所示，</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbv2c4r97gj21vc0uotdf.jpg" alt="CDA7BFAFE6E8CF7B8DD9E99993FD64D6.png"></p>
<p>继承关系为：</p>
<ul>
<li>AnnotationAwareAspectJAutoProxyCreator</li>
<li>-&gt;AspectJAwareAdvisorAutoProxyCreator</li>
<li>—&gt;AbstractAdvisorAutoProxyCreator</li>
<li>—–&gt;AbstractAutoProxyCreator implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</li>
</ul>
<p>其中的<code>SmartInstantiationAwareBeanPostProcessor</code>是Bean的后置处理器，同时也实现了<code>BeanFactoryAware</code>可以在容器初始化时，将beanFactory传进来进行相关操作。</p>
<p><strong>由上述分析可知，AnnotationAwareAspectJAutoProxyCreator既具有BeanPostProcessor特点, 也实现了BeanFactoryAware接口，方便操作BeanFactory。</strong></p>
<h4 id="AOP实现流程"><a href="#AOP实现流程" class="headerlink" title="AOP实现流程"></a>AOP实现流程</h4><p>上面已经介绍了AOP过程中，核心的AnnotationAwareAspectJAutoProxyCreator组件，接下来对整个AOP的流程进行梳理，主要分为如下4个步骤：</p>
<ol>
<li><p>注册<code>AnnotationAwareAspectJAutoProxyCreator</code>的BeanDefinition</p>
</li>
<li><p>创建<code>AnnotationAwareAspectJAutoProxyCreator</code>，并加入到BeanFactory</p>
</li>
<li><p>利用<code>AnnotationAwareAspectJAutoProxyCreator</code>拦截Bean的初始化，创建增强的Bean</p>
</li>
<li><p>增强Bean的调用过程</p>
</li>
</ol>
<p>IOC容器初始化的入口是如下的refresh()函数，上面1，2，3步骤，分别发生在如下标出的3个函数中，下面分别对这三个函数进行详细介绍。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzgtx2vgj20zw10wqe9.jpg" alt="Screen Shot 2020-02-15 at 10.56.17 AM.png"></p>
<p><strong>1. 注册<code>AnnotationAwareAspectJAutoProxyCreator</code>的BeanDefinition</strong></p>
<p>这一步主要是通过<code>invokeBeanFactoryPostProcessors(beanFactory)</code>函数，添加<code>AnnotationAwareAspectJAutoProxyCreator</code>的定义，最终调用的函数如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzmgsqh5j218m0oqaid.jpg" alt="Screen Shot 2020-02-15 at 12.46.45 PM.png"></p>
<p>注册的组件类型为AnnotationAwareAspectJAutoProxyCreator.class，组件名称ATUO_PROXY_CREATOR_BEAN_NAME值为internalAutoProxyCreator。</p>
<p>下面是调用栈：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbwzuwcgm7j21e00ckq7x.jpg" alt="Screen Shot 2020-02-15 at 12.54.46 PM.png"></p>
<p><strong>2. 创建<code>AnnotationAwareAspectJAutoProxyCreator</code>，并加入到BeanFactory</strong></p>
<p>这一步入口是<code>registerBeanPostProcessors(beanFactory)</code>，进入该函数后，会跳转到如下的核心函数中进行beanPostProcess的实例化。注意到之前提到过，<code>AnnotationAwareAspectJAutoProxyCreator</code>实现了BeanPostProcess接口，所以可以将其当成一个正常的后置处理器来进行实例化。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0avcjmfj21by0aa799.jpg" alt="Screen Shot 2020-02-15 at 1.10.12 PM.png"></p>
<p>从下面的debug信息可以看到，在这一步中，容器需要实例化4个后置处理器，其中最后一个就是我们关注的<code>AnnotationAwareAspectJAutoProxyCreator</code>。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0ep3jluj21b20d210u.jpg" alt="Screen Shot 2020-02-15 at 1.12.50 PM.png"></p>
<p>整个初始化后置处理器的流程，可以分为如下几步：</p>
<p>1）先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor<br>3）优先注册实现了PriorityOrdered接口的BeanPostProcessor；<br>4）再给容器中注册实现了Ordered接口的BeanPostProcessor；<br>5）注册没实现优先级接口的BeanPostProcessor；</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0izo4mrj211q0oqn55.jpg" alt="Screen Shot 2020-02-15 at 1.18.01 PM.png"></p>
<p>后置处理器<code>AnnotationAwareAspectJAutoProxyCreator</code>实例化完成之后，在接下来的Bean的实例化过程中，它会去尝试拦截Bean的初始化，如果有需要，则会创建代理增强后的Bean。</p>
<p><strong>3. 利用<code>AnnotationAwareAspectJAutoProxyCreator</code>拦截Bean的初始化，创建增强的Bean</strong></p>
<p>在之前的例子中，定义了如下的切面类，实现了相关的advice方法。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0nefn1dj215k0pe7d6.jpg" alt="Screen Shot 2020-02-15 at 1.22.17 PM.png"></p>
<p>这是Calculate类，就是需要增强的类。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx0xmzbi7j20hc072dgv.jpg" alt="Screen Shot 2020-02-15 at 1.31.49 PM.png">@w=300</p>
<p>这一步中主要关注这两个Bean的实例化。</p>
<p>这一步的入口是refresh函数中的<code>beanFactory.preInstantiateSingletons()</code>，下一步进入到<code>getBean--&gt;doGetBean</code>函数，</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3t0xzq5j218o0xe14b.jpg" alt="Screen Shot 2020-02-15 at 3.10.53 PM.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3u8s3yyj20ys044wfo.jpg" alt="Screen Shot 2020-02-15 at 3.12.38 PM.png"></p>
<p>接着进入<code>doGetBean--&gt;createBean</code>函数，<br><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx3zupf2uj212g03475x.jpg" alt="Screen Shot 2020-02-15 at 3.17.15 PM.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx40maqalj21bi0fejw9.jpg" alt="Screen Shot 2020-02-15 at 3.17.41 PM.png"></p>
<p>接着进入到<code>createBean</code>函数，会调用函数<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>试图直接返回proxy对象。</p>
<p><strong>接下来首先分析这个函数，再分析之后正常的初始化流程。<code>createBean</code>函数是理解整个AOP流程的核心。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx4945g10j216s0vetis.jpg" alt="Screen Shot 2020-02-15 at 3.26.04 PM.png"></p>
<p>进入到函数的实现，可以看到最后会去尝试调用类型为<code>InstantiationAwareBeanPostProcessor</code>的后置处理器，由于<code>AnnotationAwareAspectJAutoProxyCreator</code>实现了该接口，所以这个时候会被调用来试图返回proxy对象，但是通常情况下，增强bean不会在这里生成。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx4i1p4gej211y0xkh99.jpg" alt="Screen Shot 2020-02-15 at 3.35.20 PM.png"></p>
<p>但并不是说这个<code>AnnotationAwareAspectJAutoProxyCreator</code>就没有作用，进入到该函数的实现，可以发现在<code>shouldSkip</code>函数中会去找到所有的Advisor，也就是之前例子中的<code>LogAspects</code>类，并把这些Advisor放到BeanFactory中，方便后续创建增强的Bean。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx5y40f0wj213o0qqkav.jpg" alt="Screen Shot 2020-02-15 at 4.25.23 PM.png"></p>
<p>在获取到所有的Advisor之后，判断当前bean是否在advisedBeans中（保存了所有需要增强bean）<br>以及判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，如果是的话就跳过。</p>
<p><strong>回到<code>createBean</code>函数，下面进入到正常的Bean初始化流程，一步步跟进到initializeBean函数中</strong>，可以看到在初始化Bean的前后都会调用对应的后置处理器来完成相应的功能，但是AbstractAutoProxyCreator的实现中，在初始化Bean之前，只是直接返回Bean；但是<strong>在初始化完Bean之后，会调用对应的后置处理器，也就是在<code>applyBeanPostProcessorsAfterInitialization</code>函数中来创建增强的Bean。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx6zhw7bbj217y17u1kx.jpg" alt="Screen Shot 2020-02-15 at 5.00.58 PM.png"></p>
<p>下面对该函数进行仔细分析，</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx7z0215aj214k14i1kx.jpg" alt="Screen Shot 2020-02-15 at 5.35.30 PM.png"></p>
<p>接着分析<code>createProxy</code>函数的实现，下面省略了部分中间调用，在最后的实现中，createAopProxy会根据情况使用jdk代理或者CGLib，从代码中可以看到，当被代理类是接口或者是proxy类时，就会采用jdk动态代理，反之则采用CGLib。</p>
<p>以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx8yj3uzkj21400ia4c8.jpg" alt="Screen Shot 2020-02-15 at 6.09.40 PM.png"></p>
<blockquote>
<p>注意一点：在createAopProxy时，会判断config.isProxyTargetClass()，这个值默认为false。但是在两个地方进行设置，一个是EnableAspectJAutoProxy注解中，另一个地方是在createProxy函数中，evaluateProxyInterfaces会去查找目标类的所有interface，如果可用的话，则将其加到proxyFactory中，否则，调用setProxyTargetClass，设置为true。在本例子中，calculate类没有相关接口，所以设置为true。这也是为什么在createAopProxy函数中，会进行判断，而不是直接返回jdk动态代理的类。</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbx9fi7k0mj20z40tcdyn.jpg" alt="Screen Shot 2020-02-15 at 6.26.00 PM.png"></p>
<p><strong>4. 增强Bean的调用过程</strong></p>
<p>上面对AOP流程进行了梳理，通过代码分析了如何代理生成增强的Bean。这部分介绍在调用增强Bean的方法时，proxy对象是如何拦截方法调用的。</p>
<p>当被增强的Bean在执行时，会进入到下面的拦截执行流程，</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbyhmky2zkj21h40vgaml.jpg" alt="Screen Shot 2020-02-16 at 5.05.32 PM.png"></p>
<p>首先，根据ProxyFactory对象获取将要执行的目标方法拦截器链：<code>List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code></p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbyifaonl8j212t07edix.jpg" alt="Picture1.png"></p>
<p>进一步跟进到实现，<code>getInterceptorsAndDynamicInterceptionAdvice</code>的流程大致如下，主要是为了获取拦截链：</p>
<ol>
<li>List<Object> interceptorList保存所有拦截器，本例子中有5个拦截器，一个默认的ExposeInvocationInterceptor 和 4个增强器；</li>
<li>遍历所有的增强器，将其转为List<MethodInterceptor>；如果是MethodInterceptor，直接加入到集合中。如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；转换完成返回MethodInterceptor数组。</li>
</ol>
<p>在得到拦截链之后，如果没有拦截器链，直接执行目标方法;如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个 CglibMethodInvocation 对象，并调用 <code>mi.proceed();</code>来获取执行结果。</p>
<p>注意：拦截器链的触发过程是一个迭代的过程，</p>
<ol>
<li>如果没有拦截器执行执行目标方法，或者拦截器的索引和拦截器数组-1大小一样（指定到了最后一个拦截器）执行目标方法；</li>
<li>链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</li>
</ol>
<p>从下面的调用栈可以看到，所有的拦截器都会等待下一个拦截器调用完成后，再接着执行。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbyiu5grwlj20zq0bw7gs.jpg" alt="Screen Shot 2020-02-16 at 8.36.58 PM.png"></p>
<p>当在执行<code>Before</code>方法时，会先执行完before定义好的方法，然后再去执行正常的方法体：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbyiwqa07zj20wi04y75j.jpg" alt="Screen Shot 2020-02-16 at 8.39.32 PM.png"></p>
<p>整个拦截的流程可以总结如下图所示：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gbyixtkqwbj20ny0d0tc6.jpg" alt="Picture111111.png"></p>
<p>下面对整个AOP实现流程进行总结：</p>
<ol>
<li>@EnableAspectJAutoProxy 开启AOP功能，会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</li>
<li>AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</li>
<li>容器的创建流程：</li>
</ol>
<ul>
<li>registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</li>
<li>finishBeanFactoryInitialization（）初始化剩下的单实例bean<blockquote>
<p>a. 创建业务逻辑组件和切面组件<br>b. AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>c. 组件创建完之后，判断组件是否需要增强,如果是，则将切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；</p>
</blockquote>
</li>
</ul>
<ol start="4">
<li>执行目标方法：</li>
</ol>
<ul>
<li>代理对象执行目标方法</li>
<li>CglibAopProxy.intercept()；<blockquote>
<p>a. 得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）<br>b. 利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>c. 效果：<br>正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>出现异常：前置通知-》目标方法-》后置通知-》异常通知</p>
</blockquote>
</li>
</ul>
<h3 id="5-6-Spring-AOP-VS-AspectJ"><a href="#5-6-Spring-AOP-VS-AspectJ" class="headerlink" title="5.6 Spring AOP VS AspectJ"></a>5.6 Spring AOP VS AspectJ</h3><p>之前介绍的都是标准的Spring AOP实现，通过在运行时对目标类增强，生成代理类。但是利用AspectJ同样可以实现增强，只是后者是编译时增强，而且与Spring框架没有关系，可以独立运行。</p>
<p>下面先简单介绍AspectJ的使用，然后将其与Spring AOP进行对比。</p>
<h4 id="AspectJ的使用"><a href="#AspectJ的使用" class="headerlink" title="AspectJ的使用"></a>AspectJ的使用</h4><ol>
<li>下载AspectJ并安装：<a target="_blank" rel="noopener" href="http://www.eclipse.org/aspectj/downloads.php">http://www.eclipse.org/aspectj/downloads.php</a></li>
<li>实现HelloWord</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">业务组件  SayHelloService</span><br><span class="line">package com.ywsc.fenfenzhong.aspectj.learn;</span><br><span class="line">public class SayHelloService &#123;</span><br><span class="line">    public void say()&#123;</span><br><span class="line">        System.out.print(&quot;Hello  AspectJ&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>需要来了，在需要在调用say()方法之后，需要记录日志。那就是通过AspectJ的后置增强吧。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LogAspect 日志记录组件，实现对SayHelloService 后置增强</span><br><span class="line">public aspect LogAspect&#123;</span><br><span class="line">    pointcut logPointcut():execution(void SayHelloService.say());</span><br><span class="line">    after():logPointcut()&#123;</span><br><span class="line">         System.out.println(&quot;记录日志 ...&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>编译SayHelloService</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行命令   ajc -d . SayHelloService.java LogAspect.java</span><br><span class="line">生成 SayHelloService.class</span><br><span class="line">执行命令    java SayHelloService</span><br><span class="line">输出  Hello AspectJ  记录日志</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ajc.exe 可以理解为 javac.exe 命令，都用于编译 Java 程序，区别是 ajc.exe 命令可识别 AspectJ 的语法；我们可以将 ajc.exe 当成一个增强版的 javac.exe 命令.执行ajc命令后的 SayHelloService.class 文件不是由原来的 SayHelloService.java 文件编译得到的，该 SayHelloService.class 里新增了打印日志的内容——这表明 AspectJ 在编译时“自动”编译得到了一个新类，这个新类增强了原有的 SayHelloService.java 类的功能，因此 AspectJ 通常被称为编译时增强的 AOP 框架。</p>
</blockquote>
<h4 id="Spring-AOP和AspectJ对比"><a href="#Spring-AOP和AspectJ对比" class="headerlink" title="Spring AOP和AspectJ对比"></a>Spring AOP和AspectJ对比</h4><p><strong>1. 从目标角度讲：</strong></p>
<ul>
<li>Spring AOP侧重于在IOC容器中，提供了一个简单的AOP实现，它并不是一个完整的AOP解决方案，只适用于被IOC容器管理的Bean。</li>
<li>AspectJ是原始的AOP方案，目标是提供一套完整的AOP解决方案。相比Spring AOP，鲁棒性更强，可以适用于所有的对象，但是也更加复杂。</li>
</ul>
<p><strong>2. 织入（Weaving）</strong></p>
<p>AspectJ利用了下面3种不同的织入方法：</p>
<ol>
<li>Compile-time weaving: The AspectJ compiler takes as input both the source code of our aspect and our application and produces a woven class files as output</li>
<li>Post-compile weaving: This is also known as binary weaving. It is used to weave existing class files and JAR files with our aspects</li>
<li>Load-time weaving: This is exactly like the former binary weaving, with a difference that weaving is postponed until a class loader loads the class files to the JVM</li>
</ol>
<p>相比于AspectJ，Spring AOP利用了运行时织入（runtime weaving）。</p>
<p>通过动态织入，切面方法被动态的织入到程序的运行过程中，通常有JDK动态代理或者CGLIB代理。</p>
<ul>
<li><p>Spring AOP倾向于使用JDK动态代理，只要目标对象实现了至少一个接口，Spring将会采用JDK动态代理来创建增强的Bean。</p>
</li>
<li><p>如果目标方法没有实现接口，就会采用CGLIB来实现。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gc0l5guzy6j21980muwjf.jpg" alt="Screen Shot 2020-02-18 at 3.28.16 PM.png"></p>
<p><strong>3. 连接点（Join point）</strong></p>
<p>从设计的角度讲，Spring AOP通过代理模式来实现, 例如CGLIB<strong>创建目标类的子类</strong>（如下图的实例所示），再调父类的目标方法实现AOP。但是，一旦目标父类使用了关键字final，子类无法继承，切入就不能实现。因此不能代理final类型，同样的，也不能代理static方法，因为他们不能被重写。所以通常情况下，Spring AOP只支持方法作为连接点。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mhglpmxj21980x2tl8.jpg" alt="Screen Shot 2020-02-18 at 4.12.05 PM.png"></p>
<p>AspectJ没有这种限制，在编译期直接将增强方法织入到代码中，也不需要像Spring AOP那样继承目标方法，因此可以支持更多的连接点。</p>
<p>具体比较如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mnavf7gj20wm0h0415.jpg" alt="Screen Shot 2020-02-18 at 4.19.53 PM.png"></p>
<p>总结：</p>
<p>Spring AOP是基于代理的实现方式，在程序运行时创建代理，并通过拦截链来执行切面方法。AspectJ在编译期将切面方法织入到目标类，在运行期没有其他性能损耗，因此性能上相比Spring AOP会快很多。</p>
<p>下表是一个整体的对比：</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1gc0mshjq0bj218u0pq7ap.jpg" alt="Screen Shot 2020-02-18 at 4.24.51 PM.png"></p>
<hr>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-aop-vs-aspectj">https://www.baeldung.com/spring-aop-vs-aspectj</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fe8d1e8bd63e">https://www.jianshu.com/p/fe8d1e8bd63e</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1606559/spring-aop-vs-aspectj">https://stackoverflow.com/questions/1606559/spring-aop-vs-aspectj</a></li>
</ul>
<hr>
<p>本文由『后端精进之路』原创，首发于博客 <a target="_blank" rel="noopener" href="http://teckee.github.io/">http://teckee.github.io/</a> , 转载请注明出处</p>
<p>搜索『后端精进之路』关注公众号，立刻获取最新文章和<strong>价值2000元的BATJ精品面试课程</strong>。</p>
<p><img src="http://ww1.sinaimg.cn/large/a18449c6gy1g9v9luujswj21n10l9jux.jpg" alt="后端精进之路.png"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Vincent
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lfeng.tech/2020/04/01/Spring_5_AOP/" title="Spring MVC系列-(5) AOP">https://lfeng.tech/2020/04/01/Spring_5_AOP/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/29/Spring_4_Bean_lifecycle/" rel="prev" title="Spring MVC系列-(4) Bean的生命周期">
      <i class="fa fa-chevron-left"></i> Spring MVC系列-(4) Bean的生命周期
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/06/Spring_6_Transaction/" rel="next" title="Spring MVC系列-(6) 声明式事务">
      Spring MVC系列-(6) 声明式事务 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-AOP"><span class="nav-number">1.</span> <span class="nav-text">5 AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="nav-number">1.1.</span> <span class="nav-text">5.1 什么是AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-AOP%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">5.2 AOP术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-AOP%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">5.3 AOP使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">5.4 Java动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">JDK动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">CGLIB动态代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-AOP%E5%8E%9F%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="nav-number">1.5.</span> <span class="nav-text">5.5 AOP原理深入分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AnnotationAwareAspectJAutoProxyCreator%E6%B3%A8%E5%86%8C"><span class="nav-number">1.5.1.</span> <span class="nav-text">AnnotationAwareAspectJAutoProxyCreator注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AnnotationAwareAspectJAutoProxyCreator%E5%88%86%E6%9E%90"><span class="nav-number">1.5.2.</span> <span class="nav-text">AnnotationAwareAspectJAutoProxyCreator分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">AOP实现流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-Spring-AOP-VS-AspectJ"><span class="nav-number">1.6.</span> <span class="nav-text">5.6 Spring AOP VS AspectJ</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AspectJ%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.1.</span> <span class="nav-text">AspectJ的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-AOP%E5%92%8CAspectJ%E5%AF%B9%E6%AF%94"><span class="nav-number">1.6.2.</span> <span class="nav-text">Spring AOP和AspectJ对比</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vincent"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Vincent</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/teckee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;teckee" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:h0ck@foxmail.com" title="E-Mail → mailto:h0ck@foxmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">沪ICP备19042895号-2 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'cgQ905Fj6xbazWtyi9b1hafr-gzGzoHsz',
      appKey     : '68EFTwnd9XYY352gRUJlJyMu',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
